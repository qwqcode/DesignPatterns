# 单例模式 (Singleton)

## 场景问题

### 读取配置文件的内容

考虑这样一个应用，读取配置文件的内容。

很多应用项目，都有与应用相关的配置文件，这些配置文件很多是由项目开发人员自定义的，在里面定义一些应用需要的参数数据。当然在实际的项目中，这种配置文件多采用 xml 格式，也有采用 properties 格式的，毕竟使用 Java 来读取 properties 格式的配置文件比较简单。

现在要读取配置文件的内容，该如何实现呢？

### 不用模式的解决方案

有些朋友会想，要读取配置文件的内容，这也是个困难的事情，直接读取文件的内容，然后把文件内容「存放在相应的数据对象里面」就可以了。真有那么简单吗？先实现看看吧。

为了示例简单，假设系统采用的是 properties 格式的配置文件。

(1) 直接使用 Java 来读取配置文件的示例代码如下：

```java
/**
 * 读取应用配置文件
 */
public class AppConfig {
    /**
     * 用来存放配置文件中参数 A 的值
     */
    private String parameterA;

    /**
     * 用来存放配置文件中参数 B 的值
     */
    private String parameterB;

    public String getParameterA() {
        return parameterA;
    }

    public String getParameterB() {
        return parameterB;
    }
    // ↑ 注意：只有访问参数的方法，没有设置参数的方法

    /**
     * 构造方法
     */
    public AppConfig() {
        // 调用读取配置文件的方法
        readConfig();
    }

    /**
     * 读取配置文件，把配置文件中的内容读出来设置到属性上
     */
    public void readConfig() {
        Properties p = new Properties();
        InputStream in = null;
        try {
            in = AppConfig.class.getResourceAsStream("AppConfig.properties");
            p.load(in);
            // 把配置文件中的内容读出来设置到属性上
            this.parameterA = p.getProperty("paramA");
            this.parameterB = p.getProperty("paramB");
        } catch (IOException e) {
            System.out.println("装载配置文件出错了，具体堆栈信息如下：");
            e.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

(2) 应用的配置文件，名字是 AppConfig.properties，放在 AppConfig 相同的包里面。简单示例如下：

```config
paramA=a
paramB=b
```

(3) 写个客户端来测试一下。示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        // 创建读取应用配置的对象
        AppConfig config = new AppConfig();

        String paramA = config.getParameterA();
        String paramB = config.getParameterB();

        System.out.println("paramA="+paramA+",paramB="+paramB);
    }
}
```

运行结果如下：

```
paramA=a,paramB=b
```

### 有何问题

上面的实现很简单，很容易就实现要求的功能。仔细想想，有没有什么问题呢？

看看客户端「使用这个类的地方」，是「通过 new 一个 AppConfig 的实例」来得到一个操作配置文件内容的对象，也就是说「很多地方」都需要创建 AppConfig 对象的实例。

换句话说，在系统运行期间，系统中会存在「很多个 AppConfig 的实例对象」，这有什么问题吗？

当然有问题了，试想一下，每一个 AppConfig 实例对象里面「都封装着配置文件的内容」，系统中有「多个 AppConfig 对象实例」，也就是说系统中会「同时存在」多份配置文件内容，这样会「严重浪费内存资源」。如果配置文件内容较少，问题还小一点，如果配置文件内容本来就多的话，对于系统资源的浪费问题就大了。事实上，对于 AppConfig 这种类，在运行时期，「只需要一个」实例对象就是够了。

把上面的描述进一步抽象，问题就出来了：在一个系统运行时期，某个类「只需要一个类实例」就可以了，那么应该怎么实现呢？

## 解决方案

### 使用单例模式来解决问题

用来解决上述问题的一个合理解决方案就是「单例模式 (Singleton)」。那么什么是单例模式呢？

#### 1. 单例模式的定义

> 保证一个类「仅有一个实例」，并提供一个访问它的「全局访问点」。

#### 2. 应用单例模式来解决问题的思路

仔细分析上面的问题，现在一个类能够被创建多个实例，问题的根源在于「类的构造方法是公开的」，也就是可以让类的外部「通过构造方法创建多个实例」。换句说，只要「类的构造方法」能让类的「外部访问」，就「没有办法控制」外部来创建这个类的「实例个数」。

要想控制一个类「只被创建一个实例」，那么首要的问题就是「把创建实例的权限收回来」，让「类自身」来负责自己「类实例的创建工作」，然后由这个类来「提供外部可访问这个类实例的方法」，这就是单例模式的实现方法。

