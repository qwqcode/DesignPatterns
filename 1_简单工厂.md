# 简单工厂

## 问题描述

```java
public interface Api {
    public void test1(String s);
}

public class Impl implements Api {
    public void test1(String s) {
        System.out.println("Now In Impl. The input s==="+s);
    }
}

public class Client {
    public static void main(String[] args) {
        Api api = new Impl();
        api.test1("Java：面向接口的编程");
    }
}
```

你会发现在客户端调用的时候，客户端不但知道了接口，同时还知道了具体实现就是 Impl。
接口的思想是“封装隔离”，而实现类 Impl 应该是被接口 Api 封装并同客户端隔离开的，
也就是说，客户端根本就不知道具体的实现类是 Impl。

问题：在 Java 编程中，出现只知道接口而不知道实现，该怎么办？
就像现在的 Client，他知道要使用 Api 接口，但是不知道该由谁来实现，也不知道如何实现，
从而得不到接口对象，就无法使用接口，该怎么办？

解决方案：使用简单工厂来解决问题。

## 解决方案

简单工厂的定义：
    提供一个创建对象实例的功能，而无须关心其具体的实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。

通过以下方式达到了最重要的“封装隔离性”

```java
public interface Api {
    public void operation(String s);
}

public class ImplA implements Api {
    public void operation(String s) {
        System.out.println("ImplA s=="+s);
    }
}

public class ImplB implements Api {
    public void operation(String s) {
        System.out.println("ImplB s=="+s);
    }
}

public class Factory {
    /**
     * 具体创建 Api 对象方法
     * @param condition 示意，从外部传入的选择条件
     * @return 创建好的 Api 对象
     */
    public static Api createApi(int condition) {
        // 应该根据某些条件去选择究竟创建哪一个具体的实现对象
        // 这些条件可以从外部传入，也可以从其他途径来获取。
        // 如果只有一个实现，可以省略条件，因为没选择的必要
        // 示意使用条件
        Api api = null;
        if (condition == 1) {
            api = new ImplA();
        } else if (condition == 2) {
            api = new ImplB();
        }
        return api;
    }
}

public class Client {
    public static void main(String[] args) {
        Api api = Factory.createApi(1);
        api.operation("正在使用简单工厂");
    }
}
```

个人评论：实例是接口的实现，有很多接口的实现，但只知道接口，而不知道有哪些实例的情况下，
    建立简单工厂类 Factory 为这些接口的实现提供一个实例化的方法，
    通过调用这些方法就能得到 Api 接口的实现实例化对象
    简而言之，就像是代码提示，提供候选项，可找到指定接口的实现

    客户端那边不知道接口的具体实现是什么，只是调用 Factory 类里面的方法，得到自己想要的功能，想要的实例化对象

事实上，简单工厂能帮助我们真正地开始面向接口编程，
像以前的做法，其实是用到了接口多态部分的功能，最重要的“封装隔离性”并没有体现出来

## 模式讲解

### 典型疑问

Q: 直接 Api api = new Impl() 和放到 Factory 里作为方法 createImpl 有什么区别？

> 理解这个问题的重点在于理解简单工厂模式所处的位置。

简单工厂是位于封装体内部，目标就是不让客户端知道封装体内部的具体实现。
简单工厂的位置是位于封装体内的，也就是简单工厂跟接口和具体的实现在一起的，
算是封装体内部的一个类，所以简单工厂知道具体的实现类是没有关系的。

一个包装边界，表示接口、实现类和工厂类组合成一个组件。
在这个封装体里面，只有「接口」和「工厂」是对外的，
也就是让外部知道并使用，所以故意漏了一些在虚线外，
而具体的实现类是不对外的，被完全包含在虚线框内。

个人评论：
    通过简单工厂模式才算是实现了封装的特性，达到了隔离的效果，
    所以区别是显而易见的，一个包装了起来，一个是散的，没有实现隔离。
    看似简单的 new Impl() 这句话从客户端移到简单工厂，其实是质的变化。

[P20] 工厂不仅可以创建实例化对象，还可以创建其他东西 -> 万能工厂

## 简单工厂的优缺点

简单工厂有以下优点：

- 帮助封装
    简单工厂虽然很简单，但是非常友好地帮助我们实现了组件的封装，然后让组件外部能「真正」面向接口编程
- 解耦
    通过简单工厂，实现了客户端和具体实现类的解耦。
    如同上面的例子，客户端根本就不知道具体是谁来实现，也不知道具体是如何实现，客户端只是通过工厂获取它需要的接口对象。

简单工厂有以下缺点：

- 可增加客户端的复杂度
    如果客户端的参数来选择具体的实现类，那么就必须让客户端能理解各个参数所代表的具体功能和含义，这样会增加客户端的使用难度，也部分暴露了内部实现，这种情况可以选用可配置的方法来实现。
- 不方便扩展子工厂
    私有化简单工厂的构造方法，使用静态方法来创建接口，也就不能通过写简单工厂类的子类来改变创建接口的方法行为了。不过，通常情况下是不需要为简单工厂创建子类的。

## 思考简单工厂

简单工厂的本质：选择实现

- 注意简单工厂的重点在于选择，实现是已经做好了的。
- 就算实现再简单，也要由具体实现类来实现，而不是在简单工厂里来实现。
- 简单工厂的目的在于为客户端来选择相应的实现，从而使得客户端和实现之间解耦。
    这样一来，具体实现发生了变化，就不用变动客户端了，这个变化会被简单工厂吸收和屏蔽掉。

- 实现简单工厂的难点在于“如何选择”实现
- 前面讲了几种传递参数的方法，那都是静态参数，还可以实现为「动态参数」
    比如，在运行期间，由工厂去读取某个内存的值，或是去读取数据库中的值，然后根据这个值选择具体的实现等

### 何时选用简单工厂

建议在以下情况下：

- 如果想要完全封装隔离具体的实现，让外部只能通过接口来操作封装体，那么可以选择简单工厂，让客户端通过工厂来获取相应的接口，而无需关心具体的实现
- 如果想要把对外创建对象的职责集中管理和控制，可以选用简单工厂，一个简单工厂可以创建很多、不相关的对象，可以把对外创建对象的职责集中到一个简单工厂来，从而实现集中管理和控制。

