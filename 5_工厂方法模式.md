# 工厂方法模式 (Factory Method)

## 场景问题

### 导出数据的应用框架

考虑到这样一个实际应用：实现一个「导出数据的应用框架」，让客户「选择数据的导出方式」，并「正真执行数据导出」。

在一些实际的企业应用中，一个公司的系统往往分散在很多个不同的地方运行，比如各个分公司或者是门市点。公司「既没有建立全公司专有网络的实力」，但又「不愿意让业务数据实时地在广域网上传递」，一个是考虑数据安全的问题，另一个是运行速度的问题。

这种系统通常会又一个「折中的方案」，那就是各个分公司内运行系统的时候是「独立的」，是在自己分公司的「局域网内运行」。「每天业务结束的时候」，各个分公司会导出自己的业务数据，然后把业务数据打包，通过网络传输给总公司，或是专人把数据送到总公司，然后由总公司进行数据导入和核算。

通常这种系统在导出数据上会有一些「约定的方式」，比如导出成「文本格式、数据库备份形式、Excel 格式、XML 格式」等。

现在就来考虑实现这样一个应用框架。在继续之前，先来了解一些关于框架的知识。

### 框架的基础知识

#### 1. 框架是什么

简单点说，**框架就是能完成一定功能的「半成品软件」。** (完成一半任务，但不全部完成)

就其本质而言，框架是一个软件，而且是一个半成品软件。所谓半成品，就是「还不能完全实现」用户需要的功能。框架知识实现用户需要功能的「一部分」，还需要「进一步加工」，才能成为一个「满足用户需要的」、「完整的软件」。因此框架级的软件，它的「主要客户是开发人员，而不是最终用户」。

延伸：有些朋友会想，既然框架只是个半成品，那么何必要去学习和使用框架呢，学习成本也不算小？那就是因为框架能完成一定的功能，也就是 "框架已经完成的一定的功能" 在吸引着开发者，让大家去学习和使用框架。

#### 2. 框架能干什么

**能完成一定功能，加快应用开发速度。**

由于框架完成了一定的功能，而且通常是一些「基础的、有难度的、通用的」功能，这就「避免」我们在开发应用的时候「完全从头开始」，而是在框架已有的功能上继续开发，也就是说「会复用框架的功能」，从而「加快应用的开发进度」。

**给我们一个精良的程序架构。**

框架定义了应用的整体架构，包括「类和对象的分割」、「各部分的主要责任」、「类和对象怎么协作」，以及「控制流程」等。

Java 界流行的框架，大多出自「大师手笔」，「设计都很精良」。基于这样的框架来开发，一般会「遵循框架已经规划好的结构来进行开发」，从而使开发应用程序的「结构也相对变得精良了」。

评论：

- 框架完成一半的任务，但不全部完成。
- 开发者 → 框架 (半成品) -加工→ 最终用户
- 框架给我们提供一个固定的规范，开发者之间也能通过框架建立起沟通的桥梁。
- 框架提供一个完备的生命周期。
- 相当于大师引导你对代码进行布局，模块进行分割。

#### 3. 对框架的理解

**基于框架来开发，事情还是那些事情，只是看谁来做的问题。**

对于应用程序和框架的关系，可以用一个图来简单描述一下：

![](img/factory-method-framework.png)

如果没有框架，那么客户要求的所有功能都由开发者自己来开发，没问题，「同样可以」实现用户需要的功能，只是开发人员的「工作多点」。

如果有了框架，框架本身完成了一定的功能，那么框架已有的功能开发人员就可以不做了，开发人员只需要完成框架没有的功能，最后同样是完成客户端要求的所有功能，但开发者的「工作就减少了」。(自己开发框架：高度自定义)

也就是说，基于框架来开发，软件要完成的功能并没有变化，还是客户要求的所有功能，也就是 “事情还是那些事情” 的意思。但是有了框架后，「框架完成了一部分功能」，然后开着再完成一部分功能，最后由「框架和开发人员合起来」完成了整个软件的功能，也就是「看这些功能 “由谁做” 的问题」。

**基于框架开发，可以「不去做框架所做的事情」，但是「应该明白框架在干什么」，以及「框架是如何实现相应功能的」。**

事实上，在实际开发中，应用程序和框架的关系「通常都不会像」上面讲述的那样，「分得那么清楚」，更多普遍的是「相互交互」的。也就是应用程序做一部分工作，框架做另一部分工作，然后应用程序再做一部分工作，框架再做另一部分工作。「如此交错」，最后由应用程序和框架组合起来完成用户的功能需求。

也用个示意图来说明，如图：

![](img/factory-method-framework-x-app.png)

如果把这个由应用程序和框架「组合再一起构成」的矩形，当作最后完成的软件。试想一下，如果你「不懂框架」在干什么，相当于框架对你来讲「是个黑河」，也就是相当于在上图中去掉框架的两块，会发现什么？没错，剩下的应用程序是「支离破碎」的，是「相互分隔开来的」。

![](img/factory-method-framework-x-app-2.png)

延伸：着会导致一个「非常致命」的问题，整个应用「是如何运转起来的」，你是「不清楚的」，也就是说对你而言，项目已经「失控」了，从项目管理的角度来讲，这是「很危险的」。

因此，在基于框架开发的时候，虽然「可以不去做框架所做的事情」，但是「应该搞明白框架在干什么」，如果「条件允许」的话，还应该搞清楚框架是「如何实现相应功能的」，「**至少应该把「大致的实现思路和实现步骤」搞清楚，这样我们才能整体地掌控整个项目，才能尽量减少出现「项目失控」的情况。**」

评论：

框架和开发是强交互的，这就是为什么需要明白框架内部工作原理的原因。(强交互 / 强关联 / 强耦合)

#### 4. 框架和设计模式的关系

**(1) 设计模式比框架「更抽象」**

框架已经是实现出来的软件了，虽然只是个「半成品的软件」，但毕竟是已经实现出来的了；而「设计模式」的「重心」还在于「**解决问题的方案上**」，也就是还「**停留在思想的层面上**」。因此设计模式比框架更为抽象。

**(2) 设计模式是比框架「更小的体系结构元素」**

如上所述，框架是已经实现出来的软件，并「实现了一系列的功能」，因此「一个框架通常会包含多个设计模式的应用」。

**(3) 框架比设计模式「更加特例化」**

框架是完成一定功能的「半成品软件」，也就是说，框架的目的很明确，就是要「解决某一个领域的某些问题」，那是具体的功能。「不同的领域实现出来的框架是不一样的」。

而设计模式还停留在「思想层面」，只要相应的问题适合用某个设计模式来解决，在不同的领域都可以应用。

因此，框架「总是针对特定领域的」，而设计模式「更加注重从思想上、方法上」来解决问题，「更加通用化」。

评论：

- 用「设计模式」来设计「框架」
- 很多特定的情况，运用不同的模式看哪个适合，特殊问题特殊考虑。换言之，某些东西只适合某些特定的设计，这样设计比较好用。就像前端、后端设计、MVC、MVVM、BS、SaaS、O2O、P2P 哈哈。

### 有何问题

分析上面要实现的应用框架，「不管用户选择什么样的导出格式」，最后「导出的都是一个文件」，而且「系统并不知道」究竟要导出成为「什么样的文件」，因此应该有一个「**统一的接口**」来「描述系统最后生成的对象」，并「操作输出的文件」。

先把导出的文件对象的接口定义出来。实例代码如下：

```java
/**
 * 导出的文件对象的接口
 */
public interface ExportFileApi {
    /**
     * 导出内容成为文件
     * @param data 示意：需要保存的数据
     * @return 是否导出成功
     */
    public boolean export(String data);
}
```

对于实现导出数据的「业务功能对象」，它应该「根据需要」来创建相应的 ExportFileApi 的实现对象，因为特定的 ExportFileApi 的「实现」是与具体的业务相关的。但是对于「实现导出数据的业务功能对象」而言，它「并不知道应该创建哪一个」ExportFileApi 的实例对象，「也不知道应该如何创建」。

也就是说：对于「实现」导出数据的业务功能对象，它需要「创建」ExportFileApi 的「具体实例对象」，但是它「只知道 ExportFileApi 接口」，而「不知道其具体的实现」，那该怎么办呢？

## 解决方案

### 使用工厂方法模式来解决问题

用来解决上述问题的一个合理的解决方案就是「工厂方法模式 (Factory Method)」。那么什么是工厂方法模式呢？

#### 1. 工厂方法模式的定义

> 定义一个「用于创建对象的接口」，让「子类决定」实例化哪一个类，「Factory Method」使一个类的实例化「延迟到」其「子类」。

注意：延迟执行的思想，延迟到「其子类」。

#### 2. 应用工厂模式来解决问题的思路

仔细分析上面的问题，事实上「在实现导出数据的业务功能对象里面」，根本就「不知道究竟要使用哪一种」导出文件的格式，因此这个对象根本就「不应该」和「具体的导出文件的对象」「耦合在一起」，它只需要「面向导出的文件对象接口」就可以了。

评论：为了实现解耦合，中间插入一层，这一层可以塞很多相同的 interface (Product) 的「实现」。

这不就自相矛盾了吗？「要求面向接口，不让和具体的实现耦合」，但「又需要创建接口的“具体实现对象”的实例」。这么解决这个矛盾啦？

**工厂方法模式的解决思路很有意思，那就是「不解决」，采用「无为而治」的方式**；不是需要「接口对象」吗，那就「定义一个方法」来创建；可是事实上它「自己是不知道如何创建」这个接口对象的 (自己不知道，但用子类创建)，没有关系，定义成「抽象**方法**」就可以了，自己实现不了，那就让「子类」来实现，这样「这个对象本身」就可以是「面向接口编程」，而「无需关心到底如何创建接口对象」了。


### 工厂方法模式的结构和说明

![](img/factory-method-structure.png)

![](img/factory-method-structure-2.png)

- Product: 定义工厂方法「所创建的对象」的接口，也就是实际「需要使用的对象」的接口。
- ConcreteProduct: 具体的 Product 接口的「实现对象」。
- Creator: 「创造器」，声明工厂方法，工厂「方法」通常会「返回一个 Product 类型的实例对象」，而且「多是抽象方法」。也可以在 Creator 里面提供工厂方法的「默认实现」，让工厂方法「返回一个缺省的 Product 类型的实例对象」。
- ConcreteCreator: 具体的「创建器对象」，覆盖实现 Creator 定义的工厂方法，返回「具体的 Product 实例」。

### 工厂方法模式示例代码

**(1) Product 定义的示例代码如下：**

```java
/**
 * 工厂方法所创建的对象的接口
 */
public interface Product {
    // 可以定义 Product 的属性和方法
}
```

**(2) Product 实现对象的示例代码如下：**

```java
/**
 * 具体的 Product 对象
 */
public class ConcreteProduct implements Product {
    // 实现 Product 要求的方法
}
```

**(3) 创建器定义的示例代码如下：**

```java
/**
 * 创建器 声明工厂方法
 */
public abstract class Creator {
    /**
     * 创建 Product 的工厂方法
     * @return Product 对象
     */
    protected abstract Product factoryMethod();

    /**
     * 示意方法，实现某些功能的方法
     */
    public void someOperation() {
        // 通常在这些方法实现中需要调用工厂方法来获取 Product 对象
        Product product = factoryMethod();
    }
}
```

**(4) 创建器实现对象的示例代码如下：**

```java
/**
 * 具体的创建器实现对象
 */
public class ConcreteCreator extends Creator {
    protected Product factoryMethod() {
        // 重新定义工厂方法，返回一个具体的 Product 对象
        return new ConcreteProduct();
    }
}
```

### 使用工厂方法模式来实现示例

要使用工厂方法来实现示例，先来按照工厂方法模式的结构，对应出「哪些是被创建的 Product，哪些是 Creator」。

分析要求实现的功能，「导出的文件对象接口 ExportFileApi」就相当于是「Product」，而「用来实现导出数据的业务功能对象」就相当于「Creator」。

把 Product 和 Creator「**分开**」后，就可以分别来实现它们了。

使用工厂模式来实现示例程序结构如图：

【待补充】[P106]

下面一起来看看代码实现。

(1) 导出的文件对象接口 ExportFileApi 的实现没有变化，这就不再赘述了。

(2) 接口 ExportFileAPi 的实现。为了示例简单，只实现导出「文本文件」格
式和「数据库备份文件」两种。

实现导出「文本文件格式」示例代码如下：

```java
/**
 * 导出成文本文件格式的对象
 */
public class ExportTxtFile implements ExportFileApi {
    public boolean export(String data) {
        // 简单示意一下，这里需要操作文件
        System.out.println("导出数据"+data+"到文本文件");
        return true;
    }
}
```

导出成「数据库备份文件」形式对象的实例代码如下：

```java
/**
 * 导出成数据库备份文件形式的对象
 */
public class ExportDb implements ExportFileApi {
    public boolean export(String data) {
        // 简单示意一下，这里需要操作数据库和文件
        System.out.println("导出数据"+data+"到数据库备份文件");
        return true;
    }
}
```

(3) 实现 ExportOperate 的示例代码如下：

```java
/**
 * 实现导出数据的业务功能对象
 */
public abstract class ExportOperate {
    /**
     * 导出文件
     * @param data 需要保存的数据
     * @return 是否成功导出文件
     */
    public boolean export(String data) {
        // 使用工厂方法
        ExportFileApi api = factoryMethod();
        return api.export(data);
    }

    /**
     * 工厂方法，创建导出的文件对象的「接口对象」
     * @return 导出文件对象的接口对象
     */
    protected abstract ExportFileApi factoryMethod();
}
```

(4) 加入了两个 Creator 实现。

创建导出成文本文件格式对象的示例代码如下：

```java
/**
 * 具体的创建器实现对象，实现「创建导出成文本格式的对象」
 */
public class ExportTxtOperate extends ExportOperate {
    protected ExportFileApi factoryMethod() {
        // 创建导出成文本文件格式的对象
        return new ExportTxtFile();
    }
}
```

创建导出成数据库备份文件形式对象的示例代码如下：

```java
/**
 * 具体的创建器实现对象，实现「创建导出成数据库备份文件形式的对象」
 */
public class ExportDBOperate extends ExportOperate {
    protected ExportFileApi factoryMethod() {
        // 创建导出成数据库备份文件形式的对象
    }
}
```

(5) 客户端直接创建「需要使用的 Creator 对象」，然后「调用相应的功能方法」。示例代码如下：

```java
public class Client {
    public static void main(String[] args) {
        // 创建需要使用的 Creator 对象
        ExportOperate operate = new ExportDBOperate(); // ← DB/File 只是 new 的不一样

        // 调用输出数据库的功能方法
        operate.export("测试数据"); // ← 但调用的方法是一样的 (return 的 Type 是一样的)
    }
}
```

运行结果如下：

```
导出数据测试数据到数据库备份文件
```

还可以「修改客户端 new 的对象」，切换成其他实现对象，试试会发生什么。看来应用工厂方法模式是很简单的，对吧。

## 模式讲解

### 认识工厂方法模式

#### 1. 工厂方法模式的功能

工厂方法模式主要功能是「让父类在不知道具体实现」的情况下，完成「自身的功能调用」；而具体的实现「延迟到子类」来实现。

这样在设计的时候，「不用考虑具体的实现」，需要某个对象，把它「通过工厂方法返回」就好了，在「使用这些对象实现功能的时候」还是「**通过接口来操作**」，这类似与「**IoC/DI**」的思想，这个在后面讲给大家稍详细点介绍。

#### 2. 实现抽象类

工厂方法的实现中，通常「父类」会是一个「抽象类」，里面「包含创建所需对象的抽象方法」，这些「抽象方法」就是「工厂方法」。

注意：这里要注意一个问题，子类在实现这些抽象方法的时候，通常「并不是正**真正的**由子类来实现**具体的功能**」，而是「在子类的方法里里面**做选择**」，选择「具体的产品实现对象」。

父类里面，通常会有「使用这些产品」来「实现一定功能的方法」，而且这些方法所实现的功能通常是「公共」的功能，「不管子类选择了何种具体的产品实现，这些方法的功能都总是能正常执行」。

#### 3. 实现成具体的类

也可以把父类「实现成为一个具体的类」，这种情况下，通常是「在父类中提供获取所需的对象**默认实现方法**」，这样「即使没有具体的子类，也能够运行」。(加个默认方法)

通常这种情况「还是需要具体的**子类来决定**」「具体要如何创建**父类所需要的对象**」。也把这种情况称为「工厂方法为子类提供了**挂钩**」。通过工厂方法，可以让子类对象来「覆盖」父类的实现，从而「提供更好的灵活性」。

#### 4. 工厂方法的参数和返回

工厂方法的实现中，「可能需要参数」，以便「决定到底选用哪一种具体的实现」。也就是说「通过在抽象方法里面**传递参数**」，在「子类实现」的时候「根据参数进行选择」，看看究竟应该「创建哪一个**具体的实现对象**」。

一般工厂方法返回的是「被创建对象的接口对象」，当然「也可以是**抽象类**或者**一个具体的类的实例**」(不局限于接口对象)。「标星」

#### 5. 谁来使用工厂方法创建的对象

这里首先要弄明白一件事情，就是谁在使用「工厂方法创建的对象」？

事实上，在工厂方法模式里面，应该是 **Creator 中的「其它方法」在使用「工厂方法创建的对象」**，这个时候「工厂方法创建的对象」，是 Creator 中的某些方法使用；

对于使用那些由 Creator 创建出来的对象，这个时候「工厂方法创建的对象」，是「构成客户端需要的对象的**一部分**」。分别举例来说明。

**1) 客户端使用 Creator 对象的情况**

比如前面的示例，对于「实现导出数据业务功能的对象」的类 ExportOperate，它有一个 export 的方法，在这个方法里面，需要使用具体的「导出的文件对象的接口对象 ExportFileApi」，而 ExportOperate 是不知道具体的 ExportFileApi 实现的，那是怎么做的呢？就是定义了一个「工厂方法」，用来返回 ExportFileApi 的对象，然后 export 方法会使用这个「工厂方法」来获取它「所需要的对象」，然后执行功能。

这个时候的客户端是怎么做的？这个时候客户端主要是使用 ExportOperate 的实例来完成它想要完成的功能，也就是客户端使用 Creator 对象的情况。简单描述这种情况下的代码结构如下：

```java
/**
 * 客户端使用 Creator 对象的情况下，Creator 的基本实现结构
 */
public abstract class Creator {
    /**
     * 工厂方法，一般不对外
     * @return 创建的产品对象
     */
    protected abstract Product factoryMethod();

    /**
     * 提供给外部使用的方法
     * 客户端一般使用 Creator 提供的这些方法来完成所需要的功能
     */
    public void someOperation() {
        // 在这里使用工厂方法
        Product p = factoryMethod();
    }
}
```

**2) 客户端使用由 Creator 创建出来的对象**

另外一种是由 Creator 向客户端返回「由工厂方法创建的对象」来构建的对象，这个时候工厂方法创建的对象，是「构成客户端需要的对象的一部分」。简单描述这种情况下的代码结构如下：

```java
/**
 * 客户端使用 Creator 来创建客户端需要的对象的情况下，Creator 的基本实现结构
 */
public abstract class Creator {
    /**
     * 工厂方法，一般不对外，创建一个部件对象
     * @return 创建的产品对象，一般是另一个产品对象的部件
     */
    protected abstract Product1 factoryMethod1();

    /**
     * 工厂方法，一般不对外，创建一个部件对象
     * @return 创建的产品对象，一般是另一个产品对象的部件
     */
    protected abstract Product2 factoryMethod();

    /**
     * 创建客户端需要的对象，客户端主要使用产品对象来完成所需要的功能
     * @return 客户端需要的对象
     */
    public Product createProduct() {
        // 在这里使用工厂方法，得到客户端所需对象的部件对象
        Product1 p1 = factoryMethod1();
        Product2 p2 = factoryMethod2();

        // 工厂方法创建的对象是创建客户端对象所需要的
        Product p = new ConcreteProduct();
        p.setProduct1(p1); // ← 这里用到注入的思想了
        p.setProduct2(p2);

        return p;
    }
}
```

小结一下：在工厂方法模式里，客户端「要么使用 Creator 对象，要么使用 Creator 创建的对象」，「一般客户端不直接使用工厂方法」。当然也可以直接把工厂方法暴露给客户端操作，但是一般不这么做。

#### 工厂方法模式的调用顺序示意图

由于客户端使用 Creator 对象有两种典型情况，因此调用的顺序示意图也分为两种情况。

先看看客户端「使用 Creator 创建出来的对象」情况的调用顺序示意图，如图：

![](img/factory-method-client-call-1.png)

接下来看看客户端「使用 Creator 对象」时候的调用顺序示意图，如图：

![](img/factory-method-client-call-2.png)


转到：[工厂方法模式 (下)](./5_工厂方法模式_2.md)
