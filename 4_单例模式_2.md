## 模式讲解

### 认识单例模式

#### 1. 单例模式的功能

单例模式是用来保证这个类在运行期间「只会被创建一个实例」，另外，单例模式还提供了一个「全局唯一」访问这个类实例的访问点，就是 getInstance 方法。不管采用懒汉式，还是饿汉式的实现方式，这个全局访问点是一样的。

对于单例模式而言，不管采用何种实现方式，它都是「只关心实例的创建问题」，「并不关心具体的业务功能」。

#### 2. 单例模式的范围

也就是多大的范围内是单例呢？

观察上面的实例可以知道，目前 Java 里面使用的单例是一个「虚拟机的范围」。因为装载类的功能是虚拟机，所以一个虚拟机在通过自己的 ClassLoader 装载饿汉式实例的单例类的时候会创建一个类的实例。(这里需要一些 Java 虚拟机的知识)

这就以为着，如果一个「虚拟机」里面有「多个 ClassLoader」，而且这些 ClassLoader 都装载某个类的话，这算是这个类的「单例」，它也会产生多个实例。当然，如果一个机器上有「多个虚拟机」，那么每个虚拟机里面都应该至少有一个这个类的实例，也就是说整个机器上就有很多个实例，更不会是单例了。(上升到了 Java 虚拟机的范畴)

#### 3. 单例模式的命名

注意：另外请注意一点，这里讨论的单例模式「不适用于集群环境」，对于集群环境下的单例这里不去讨论，它不属于这里的内容范畴。

一般建议单例模式的方法命名为 getInstance()，这个方法的返回类型肯定是单例类的类型了。getInstance() 方法「可以有参数」，这些参数可能是「创建类实例所需要的参数」，当然，大多数情况下是「不需要」的。

单例模式的名称有：单例、单件、单体等，只是翻译的不同，都是指的同一个模式。

### 懒汉式和饿汉式实现

前面提到了单例模式有两种典型的方案，一种叫「懒汉式」，另一种叫「饿汉式」，这两种方法究竟是如何实现的，下面分别来看看。

为了更清晰一点，只是实现基本的单例控制部分，不再提供示例的「属性和方法」了；而且暂时也不去考虑线「程安全的问题」，这个问题在后面会重点分析。

#### 1. 第一种方案——懒汉式

**(1) 私有化构造方法**

要想在运行期间控制某一个类的实例只有一个，首要任务就是「要控制创建实例的地方」，也就是「不能随随便便就可以创建类实例」，否则就「无法控制创建实例的个数」了。

现在是让使用类的地方创建实例，也就是在类外部来创建实例。

那么怎样才能「让类的外部不能创建一个实例」呢？很简单，「私有化构造方法」就可以了。示例代码如下：

```java
private Singleton() {

}
```


**(2) 提供获取实例的方法**

构造方法被私有化了，外部使用这个类的地方不干了，外部创建不了类实例就没有办法调用这个对象的方法，就实现不了功能调用。这可不行，经过思考，单例模式决定让这个类提供一个方法来返回类的实例，方便外面使用。实例代码如下：

```java
public Singleton getInstance() {

}
```

**(3) 把获取实例的方法变成静态的**

又有新的问题了，获取对象实例的这个方法就是一个实例方法，也就是说客户端想要调用这个方法，首先要先得到类实例，然后才可以调用。可是这个方法就是为了得到类实例，这样一来不就形成了一个「死循环」了吗？这也是典型的「先有鸡还是先有蛋问题」。

解决方法也很简单，「在方法上加上 static」，这样就可以直接通过类来调用这个方法，而不需要先得到类的实例。示例代码如下：

```java
public static Singleton getInstance() {
    
}
```

**(4) 定义存储实例的属性**

方法定义好了，那么方法内部如何实现呢？如果直接创建实例并返回，这样行不行呢？实例代码如下：

```java
public static Singleton getInstance() {
    return new Singleton();
}
```

当然不行了，如果每次客户端访问这样直接 new 一个实例，那肯定会有多个实例，根本实现不了单例的功能。

怎么办呢？单例模式想到了一个方法，那就是「用一个属性来记录自己创建好的类实例」。当「第一次创建后，就把这个实例保存下来」，以后就可以「复用」这个实例，而不是重复创建对象实例了。示例代码如下：

```java
private Singleton instance = null;
```

**(5) 把这个属性也定义成静态的**

这个属性变量应该在什么地方用呢？肯定是「第一次创建类示例的地方」，也就是在前面那个「返回对象实例的静态方法里面使用」。

由于要在第一个静态方法里面使用，所以「这个属性被迫称为一个类变量」，要强制加上「static」，也就是说，这里并没有使用 static 的特性。示例代码如下：(编译器说了算，哈哈)

```java
private static Singleton instance = null;
```

**(6) 实现控制实例的创建**

现在应该到 getInstance 方法里面实现控制实例的创建了。控制方法很简单，只要「先判断一下是否已经创建过实例」就可以了。如何判断？那就看存放实例的属性是否有值，如果有值，说明已经创建过了，如果没有值，则应该创建一个。示例代码如下：

```java
public static Singleton getInstance() {
    // 先判断 instance 是否有值
    if (instance == null) {
        // 如果没有值，说明还没有创建过实例，那就创建一个
        instance = new Singleton();
    }
    // 如果有值，或者是创建了值，那就直接使用
    return instance;
}
```

**(7) 完整的实现**

至此，成功解决了在运行期间，控制某个类只能被创建一个实例的要求。完整的代码如下。为了大家好理解，用注释标示了代码的先后顺序。

```java
public class Singleton {
    // 4: 定义一个变量来存储创建好的类实例
    // 5: 因为这个变量要在静态方法中使用，所以需要加上 static 修饰
    private static Singleton instance = null;

    // 1: 私有化构造方法，好在内部控制创建实例的数目
    private Singleton() {

    }

    // 2: 定义一个发方法来为客户端提供类实例
    // 3: 这个方法需要定义成类方法，也就是要加 static
    public static Singleton getInstance() {
        // 6: 判断存储实例的变量是否有值
        if (instance == null) {
            // 6.1: 如果没有，就创建一个类的实例，并把赋值给存储类实例的变量
            instance = new Singleton();
        }
        // 6.2: 如果有值，那就直接使用
        return instance;
    }
}
```

#### 2. 第二种方案——饿汉式

这种方案和第一种方案相比，前面的私有化构造方法，提供静态的 getInstance 方法来返回实例等步骤都一样。差别就在于「如何实现 getInstance 方法」，在这个地方，单例模式还想到了「另外一种方法」来实现 getInstance 方法。

不就是要控制只创造一个实例吗？那么有没有什么现成的解决方法呢？很快，单例模式回忆起了 Java 中 static 特性。

- static 变量「只在类装载的时候进行初始化」。
- 多个实例 static 变量「会共享同一块内存区域」。

评论：饿汉式依赖于面向对象语言，如 Java 的 static 特性。

这就意味着，在 Java 中，static 变量「只会被初始化一次」，就是在类装载的时候，而且多个实例就会「共享这个内存空间」，这不就是单例模式要实现的功能吗？真是的来全不费功夫啊。根据这些知识，写出了第二种解决方案的代码。

```java
public class Singleton {
    // 4: 定义一个静态变量来存储创建好的类实例
    // 直接在这里创建类实例，只能创建一次
    private static Singleton instance = new Singleton(); // 注意在这里就创建类实例了 (某些语言似乎不能这样干)

    // 1: 私有化构造方法，可以在内部控制创建实例的数目
    private Singleton() {

    }

    // 2: 定义一个方法来为客户端提供类实例
    // 3: 这个方法需要定义成类方法，也就是要加 static
    public static Singleton getInstance() {
        // 5: 直接使用已经创建好的实例
        return instance;
    }
}
```

注意一下：这个方案用到了 static 的特性，而第一个方案却没有用到，因此两个方案步骤会有一些不同。在第一个方案里面，强制加上 static 也算是一步的，而在这个方案里面是主动加上 static，就不能单独算作一步了。

所以在查看上面两种方案代码的时候，仔细看看编号。顺着编号顺序来看，可以体会两种方案的不一样。

不管是采用哪一种方式，在运行期间，都「只会生成一个实例」，而「访问这些类的一个全局访问点」，就是那个「静态的 getInstance 方法」。

#### 3. 单例模式的调用顺序示意图

由于单例模式有两种实现方式，所以它的调用顺序也分为两种。

先来看看懒汉式的调用顺序：

【待补充】[P86]

饿汉式的调用顺序如图：

【待补充】

### 延迟加载的思想

单例模式的「懒汉式」实现方式体现了「延迟加载的思想」。

什么是延迟加载呢？

通俗点说，延迟加载就是「一开始不要加载资源或数据」，一直等，「等到马上就要使用这个资源或者数据了」，躲不过去了才加载，所以也称「Lazy Load」，不是懒惰啊，是“延迟加载”，这在实际开发中也是「一种很常见的思想」，「尽可能地节约资源」。

(As Lazy as possible.)

体现在什么地方呢？请看如下代码：

```java
public static Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    // ↑ 这里就体现了延迟加载，
    // 马上就要使用这个实例了，
    // 还不知道有没有呢，所以判断一下，
    // 如果没有，没办法了，赶紧创建一个吧。
    return instance;
}
```

### 缓存的思想

单例模式的「懒汉式」实现还体现了「缓存的思想」，缓存也是实际开发中「常见的功能」。

简单讲就是，当某些资源或者数据「被频繁地使用」，而这些资源和数据存储在系统外部，比如数据库、硬盘文件等，那么每次操作这些数据的时候都得从数据库或者硬盘上去获取，速度会很慢，将造成性能问题。(外部存储设备通常没有内部快，并且除了 RAM，还有 CPU 的三级缓存，速度更快。把外部存储的内容加载到更快的地方，实现高效 IO)

一个简单的解决方法就是：「把这些数据缓存到内存里面」，每次操作的时候，先到内存里面找，看看有没有这些数据，「如果有，就直接使用，如果没有就获取它，并设置到缓存中」，「下一次访问的时候就可以直接从内存中获取了」，从而节省大量时间。当然，「**缓存是一种典型的空间换时间的方案**」。「标星」

缓存在单例模式的实现中是怎样体现的呢？

```java
public class Singleton {
    private static Singleton instance = null;
    // ↑ 这个属性是用来缓存实例的

    private Singleton() {

    }

    // ↓ 缓存的实现
    public static Singleton getInstance() {
        // 判断存储实例的变量是否有值
        if (instance == null) {
            // 如果没有，就创建一个类实例，并把值赋给存储类实例的变量
            instance = new Singleton();
        }
        // 如果有值，那就直接使用
        return instance;
    }
}
```

### Java 中缓存的基本实现

下面来看看在 Java 开发中缓存的基本实现，在 Java 开发中「最常见的一种实现缓存的方式」就是「使用 Map」，基本步骤如下：

(1) 先到缓存里面查找，看看是否存在需要使用的数据。
(2) 如果没有找到，那么就「创建一个满足要求的数据」，然后把这个数据设置到缓存中，「以备下次使用」。如果找到了相应的数据，或者是创建了相应的数据，那就直接使用这个数据。

还是看看示例吧。示例代码如下：

```java
/**
 * Java 中缓存的基本实现示例
 */
public class JavaCache {
    /**
     * 缓存数据的容器，定义成 Map 是方便访问，直接根据 key 就可以获取 value 了
     * key 选用 String 是为了简单，方便演示
     */
    private Map<String, Object> map = new HashMap<String, Object>();

    /**
     * 从缓存中获取值
     * @param key 设置时候的 key 值
     * @return key 对应的 value 值
     */
    public Object getValue(String key) {
        // 先从缓存里面取值
        Object obj = map.get(key);

        // 判断缓存里面是否有值
        if (obj == null) {
            // 如果没有，那么就去获取相应的数据，比如读取数据库或文件
            // 这里只是演示，所以直接写个假的值
            obj = key+",value";
            // 把获取的值设置到缓存里面
            map.put()
        }

        // 如果有值了，就直接返回使用
        return obj;
    }
}
```

这里只是缓存的基本实现，还有很多功能没有考虑，比如「缓存的清楚、缓存的同步等」。当然，Java 的缓存还有很多实现方式，也是非常复杂的，现在有很多专业的缓存框架。更多缓存的知识，这里就不再讨论了。

评论：

突然想到了之前 immersive-registry 项目中把缓存存到 redis 里面，是从 redis 里面查缓存是否存在，其实也可以适当将某些数据存到 golang 的 Slice 里面，从而获取更快的查询速度。但是全部交给 redis 有个好处，就是可以一定程度上避免内存爆炸的问题。

### 利用缓存来实现单例模式

应用 Java 缓存的知识，可以「变相实现 Singleton 模式」，也算是一个「模拟实现」把。只要创建一次对象实例后，就设置了缓存的值，那么下一次就不用再创建了。

虽然不是很标准的做法，但是同样可以实现单例模式的功能。为了简单，先不考虑多线程的问题，实例代码如下：

```java
/**
 * 使用缓存来模拟实现单例模式
 */
public class Singleton {
    /**
     * 定义一个默认的 key 值，用来标识再缓存中的存放
     */
    private final static String DEFAULT_KEY = "One";

    /**
     * 缓存实例的容器
     */
    private static Map<String, Singleton> map = new HashMap<String, Singleton>();

    /**
     * 私有化构造方法
     */
    private Singleton() {
        //
    }

    public static Singleton getInstance() {
        // 先从缓存中获取
        Singleton instance = (Singleton)map.get(DEFAULT_KEY);
        // 如果没有，就创建一个，让后设置回缓存中
        if (instance == null) {
            instance = new Singleton();
            map.put(DEFAULT_KEY, instance);
        }
    }
}
```

是不是也能实现单例模式所要求的功能呢？前面讲过，「实现模式的方式有很多种，并不是只有模式的参考实现所实现的方式」，上面这种也能实现单例模式所要求的功能，只不过实现比较麻烦，不是太好而已，但再后面「扩展单例模式」的时候会用到。

另外，前面也讲过，「模式是经验的积累，模式的参考实现并不一定是最优的」，对于单例模式，后面将会给大家一些更好的实现方法。

评论：

看到最后，觉得作者说得很对！在开始看这一小节的时候，我思考既然有简单的方法，为什么要提出这个例子呢？所以，作者是想表明：设计模式的思想和具体的实现是分开的，具体实现有很多方式，参考实现并不一定是最佳实践，需要找到适合的。这里讲了 Java 的缓存知识，结合上面的例子拓宽视野，进一步感受到设计模式思想的实现可以高度自定义，从而满足特定的需求。

## 单例模式的优缺点

### 1. 时间和空间

比较上面两种写法：「**懒汉式是典型的时间换空间**」，也就是每次获取实例都会判断，看是否需要创建实例，「浪费判断的时间」。当然，如果一直没人使用的话，那就不会创建实例，则「节约内存空间」。

「**饿汉式是典型的空间换时间**」，当类装载的时候就会创建类实例，不管你用不用，先创建出来 (而占用了内存空间)，然后每次调用的时候，就不需要在判断了，「节省了运行时间」。

#### 2. 线程安全

(1) 从线程安全性上讲，「**不加同步的懒汉式是线程不安全的**」，比如，有两个线程，一个是线程 A，一个是线程 B，它们同时调用 getInstance 方法，那就可能「导致并发问题」。

如下示例：

```java
// ↓ B 线程运行到这句话，正在进行判断中
public static Singleton getInstance() {
    if (instance == null) {
        // A 线程已经运行到这里了，还没有执行完下面一句话；
        // 而此时 B 线程运行到上面了，还在进行判断
        instance = new Singleton();
    }

    return instance;
}
```

程序继续运行，两个线程都向前走了一步，如下：

```java
public static Singleton getInstance() {
    if (instance == null) {
        // 1: 由于 B 线程运行较快，一下就判断出 instance == null，为 true
        // 2: 而此时 A 线程正在创建实例，也就是正运行 new Singleton()
        // 3: 但是 B 线程已经判断完了，也进入到这里了 (然后就重复创建实例了)

        instance = new Singleton(); // ← A 线程正在创建实例
        
        // 问题就产生了；这样就没有控制住，并发了，会创建两个实例了。
    }

    return instance;
}
```

可能有些朋友会觉得文字描述不够直观，再来画个图说明一下，如图：

【待补充】[P91]

通过图中分解描述，明显看出，当 A、B 线程并发的情况下，会创建出两个实例来，也就是「单例的控制在并发的情况下失效了」。(单例控制，并发失效)

(2)「**饿汉式是线程安全的**」，因为虚拟机保证「只会装载一次」，在装载类的时候是「不会发生并发的」。

(3) 如何实现懒汉式的线程安全呢？

当然懒汉式也是「可以实现线程安全的」，只要加上「synchronized」即可，如下：

```java
public static synchronized Singleton getInstance() { }
```

但是这样一来，「会降低整个访问的速度」，而且每次都要判断。那么有没有「更好的方式」来实现呢？

评论：

- 懒汉式因为在并发时会出现单例数量控制失效问题，所以是线程不安全的。
- 而饿汉式由于不会在对象实例化时并发操作，所以是线程安全的。
- 想要让懒汉式也变得线程安全，可以直接使用 synchronized 修饰符，但是效率会降低，更好的解决方式是使用下面的「双重检查加锁」。(好高级的名字对吧，哈哈)

(4) 双重检查加锁

【未完待续...】